<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>HdrHistogram算法和实现 | Blog</title>
<meta property="og:title" content="HdrHistogram算法和实现 | Blog"><meta name=twitter:title content="HdrHistogram算法和实现 | Blog"><meta itemprop=name content="HdrHistogram算法和实现 | Blog"><meta name=application-name content="HdrHistogram算法和实现 | Blog"><meta property="og:site_name" content="Blog"><meta name=description content="blog"><meta itemprop=description content="blog"><meta property="og:description" content="blog"><meta name=twitter:description content="blog"><meta property="og:locale" content="en-gb"><meta name=language content="en-gb"><link rel=alternate hreflang=en-gb href=https://zingdle.github.io/posts/2025-01-14-hdrhistogram/ title=English><meta property="og:type" content="article"><meta property="og:article:published_time" content=2025-01-14T20:07:06+0800><meta property="article:published_time" content=2025-01-14T20:07:06+0800><meta property="og:url" content="https://zingdle.github.io/posts/2025-01-14-hdrhistogram/"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"HdrHistogram算法和实现","author":{"@type":"Person","name":""},"datePublished":"2025-01-14","description":"","wordCount":344,"mainEntityOfPage":"True","dateModified":"2025-01-14","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Blog"}}</script><meta name=generator content="Hugo 0.140.0"><meta property="og:url" content="https://zingdle.github.io/posts/2025-01-14-hdrhistogram/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="HdrHistogram算法和实现"><meta property="og:description" content='背景 想必大家对延迟（latency）指标一定不会不陌生，它衡量的是事件响应时间的快慢，常见的有网络延迟等。考虑到平均延迟会掩盖真实的问题，监控中一般都采用百分位（Quantile）指标进行评价，如P50/P90/P99，表示前50%/90%/99%的延迟数据。
简单地，我们可以将延迟数据排序，然后取对应百分位的数据即可得到Quantile指标，但显然这样的空间开销和排序时间开销都比较大，不是一个合适的做法。目前工业界和学术界都有比较成熟的百分位计算方法，这些方法都有不同的侧重点，有的更关注并行计算能力，有的更关注准确度。常见的百分位算法可以分为如下几类：
基于样本的 蓄水池采样 基于桶的 基于静态桶 HdrHistogram 基于动态桶 CKMS, t-digest 简单来说，百分位算法需要支持接口：
struct quantile_algo { void add(int x); int percentile_at(double percentile); } add方法将某个数据加入统计，percentile_at方法计算对应的百分位指标。
本文关注的是如何更快地在线计算延迟。这里的更快，指的是也是更低的延迟，更准确的说是add方法的延迟。一般来说percentile_at方法相对调用频率较少，且不在关键路径上。
不同Quantile算法的介绍、时间和空间复杂度对比可见这篇文章。这里我们直接说结论，HdrHistogram更符合我们的场景，所以本文着重关注的也是HdrHistogram。
HdrHistogram 上面我们提到，HdrHistogram基于静态桶做百分位计算。那么什么叫基于桶的算法呢？考虑到空间开销和时间的开销，我们不能把所有的数据都准确记录下来，那么只能用关键点来sketch多个数据，桶就是sketch数据特征的手段。 举个例子，统计延迟时，如果数据都分布在300ms内，那么可以划分为3个桶:
Bucket 1 2 3 Range [0, 100) [100, 200) [200, 300) 当新遇到一个延迟数据，我们只需要将对应的桶计数+1即可。当有90%的数据都分布在前两个桶中时，我们可以说P90是200ms了。显然这种sketch肯定是有损的，很多情况下不能准确得到Quantile的值，但桶越多，精确度也会越高。
上面的例子中我们提前知道数据分布范围，但是如果数据的变化较大，不好提前划分桶该怎么办呢？HdrHistogram采用了一种讨巧的方式，结合了指数划分和等间距划分两种分桶方式，将区间内的桶压缩表示出来。取一段代码注释 （修改了typo后）：
/// `Histogram` is the core data structure in HdrSample. It records values, and performs analytics. /// /// At its heart, it keeps the count for recorded samples in "buckets" of values. The resolution /// and distribution of these buckets is tuned based on the desired highest trackable value, as /// well as the user-specified number of significant decimal digits to preserve. The values for the /// buckets are kept in a way that resembles floats and doubles: there is a mantissa and an /// exponent, and each bucket represents a different exponent. The "sub-buckets" within a bucket /// represent different values for the mantissa. /// /// To a first approximation, the sub-buckets of the first /// bucket would hold the values `0`, `1`, `2`, `3`, …, the sub-buckets of the second bucket would /// hold `0`, `2`, `4`, `6`, …, the third would hold `0`, `4`, `8`, and so on. However, the low /// half of each bucket (except bucket 0) is unnecessary, since those values are already covered by /// the sub-buckets of all the preceeding buckets. Thus, `Histogram` keeps the top half of every /// such bucket. /// /// For the purposes of explanation, consider a `Histogram` with 2048 sub-buckets for every bucket, /// and a lowest discernible value of 1: /// /// <pre> /// The 0th bucket covers 0...2047 in multiples of 1, using all 2048 sub-buckets /// The 1st bucket covers 2048..4095 in multiples of 2, using only the top 1024 sub-buckets /// The 2nd bucket covers 4096..8191 in multiple of 4, using only the top 1024 sub-buckets /// ... /// </pre> HdrHistogram将桶分成了2层，bucket和sub-bucket，同一bucket内不同sub-bucket等间隔划分，不同bucket指数级别划分。'><meta property="og:locale" content="en_gb"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-14T20:07:06+08:00"><meta property="article:modified_time" content="2025-01-14T20:07:06+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="HdrHistogram算法和实现"><meta name=twitter:description content='背景 想必大家对延迟（latency）指标一定不会不陌生，它衡量的是事件响应时间的快慢，常见的有网络延迟等。考虑到平均延迟会掩盖真实的问题，监控中一般都采用百分位（Quantile）指标进行评价，如P50/P90/P99，表示前50%/90%/99%的延迟数据。
简单地，我们可以将延迟数据排序，然后取对应百分位的数据即可得到Quantile指标，但显然这样的空间开销和排序时间开销都比较大，不是一个合适的做法。目前工业界和学术界都有比较成熟的百分位计算方法，这些方法都有不同的侧重点，有的更关注并行计算能力，有的更关注准确度。常见的百分位算法可以分为如下几类：
基于样本的 蓄水池采样 基于桶的 基于静态桶 HdrHistogram 基于动态桶 CKMS, t-digest 简单来说，百分位算法需要支持接口：
struct quantile_algo { void add(int x); int percentile_at(double percentile); } add方法将某个数据加入统计，percentile_at方法计算对应的百分位指标。
本文关注的是如何更快地在线计算延迟。这里的更快，指的是也是更低的延迟，更准确的说是add方法的延迟。一般来说percentile_at方法相对调用频率较少，且不在关键路径上。
不同Quantile算法的介绍、时间和空间复杂度对比可见这篇文章。这里我们直接说结论，HdrHistogram更符合我们的场景，所以本文着重关注的也是HdrHistogram。
HdrHistogram 上面我们提到，HdrHistogram基于静态桶做百分位计算。那么什么叫基于桶的算法呢？考虑到空间开销和时间的开销，我们不能把所有的数据都准确记录下来，那么只能用关键点来sketch多个数据，桶就是sketch数据特征的手段。 举个例子，统计延迟时，如果数据都分布在300ms内，那么可以划分为3个桶:
Bucket 1 2 3 Range [0, 100) [100, 200) [200, 300) 当新遇到一个延迟数据，我们只需要将对应的桶计数+1即可。当有90%的数据都分布在前两个桶中时，我们可以说P90是200ms了。显然这种sketch肯定是有损的，很多情况下不能准确得到Quantile的值，但桶越多，精确度也会越高。
上面的例子中我们提前知道数据分布范围，但是如果数据的变化较大，不好提前划分桶该怎么办呢？HdrHistogram采用了一种讨巧的方式，结合了指数划分和等间距划分两种分桶方式，将区间内的桶压缩表示出来。取一段代码注释 （修改了typo后）：
/// `Histogram` is the core data structure in HdrSample. It records values, and performs analytics. /// /// At its heart, it keeps the count for recorded samples in "buckets" of values. The resolution /// and distribution of these buckets is tuned based on the desired highest trackable value, as /// well as the user-specified number of significant decimal digits to preserve. The values for the /// buckets are kept in a way that resembles floats and doubles: there is a mantissa and an /// exponent, and each bucket represents a different exponent. The "sub-buckets" within a bucket /// represent different values for the mantissa. /// /// To a first approximation, the sub-buckets of the first /// bucket would hold the values `0`, `1`, `2`, `3`, …, the sub-buckets of the second bucket would /// hold `0`, `2`, `4`, `6`, …, the third would hold `0`, `4`, `8`, and so on. However, the low /// half of each bucket (except bucket 0) is unnecessary, since those values are already covered by /// the sub-buckets of all the preceeding buckets. Thus, `Histogram` keeps the top half of every /// such bucket. /// /// For the purposes of explanation, consider a `Histogram` with 2048 sub-buckets for every bucket, /// and a lowest discernible value of 1: /// /// <pre> /// The 0th bucket covers 0...2047 in multiples of 1, using all 2048 sub-buckets /// The 1st bucket covers 2048..4095 in multiples of 2, using only the top 1024 sub-buckets /// The 2nd bucket covers 4096..8191 in multiple of 4, using only the top 1024 sub-buckets /// ... /// </pre> HdrHistogram将桶分成了2层，bucket和sub-bucket，同一bucket内不同sub-bucket等间隔划分，不同bucket指数级别划分。'><link rel=canonical href=https://zingdle.github.io/posts/2025-01-14-hdrhistogram/><link href=/style.min.e28ccf6a7d41ec71329c0060f3934cd5d977837a2e9476c452989772d5bd2eec.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/icons/favicon-16x16.png><link rel=mask-icon href=/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=/favicon.ico><link rel=manifest href=https://zingdle.github.io/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=/icons/favicon.svg></head><body data-theme=auto class=notransition><script src=/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://zingdle.github.io/ class=logo><svg width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>Home</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
</a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/>Home</a></li><li><a class="menu-link active" href=/posts/>Posts</a></li><li><a class=menu-link href=/pages/about/>About</a></li><li class=menu-separator><span>|</span></li></ul><a id=mode href=#><svg class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>HdrHistogram算法和实现</h1><div class=post-meta><time datetime=2025-01-14T20:07:06+08:00 itemprop=datePublished>14 Jan 2025</time></div></header><div class=page-content><h2 id=背景>背景</h2><p>想必大家对延迟（latency）指标一定不会不陌生，它衡量的是事件响应时间的快慢，常见的有网络延迟等。<a href=https://www.elastic.co/cn/blog/averages-can-dangerous-use-percentile>考虑到平均延迟会掩盖真实的问题</a>，监控中一般都采用百分位（Quantile）指标进行评价，如P50/P90/P99，表示前50%/90%/99%的延迟数据。</p><p>简单地，我们可以将延迟数据排序，然后取对应百分位的数据即可得到Quantile指标，但显然这样的空间开销和排序时间开销都比较大，不是一个合适的做法。目前工业界和学术界都有比较成熟的百分位计算方法，这些方法都有不同的侧重点，有的更关注并行计算能力，有的更关注准确度。常见的百分位算法可以分为如下几类：</p><ul><li>基于样本的<ul><li>蓄水池采样</li></ul></li><li>基于桶的<ul><li>基于静态桶<ul><li>HdrHistogram</li></ul></li><li>基于动态桶<ul><li>CKMS, t-digest</li></ul></li></ul></li></ul><p>简单来说，百分位算法需要支持接口：</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#c678dd>struct</span> <span style=color:#e5c07b>quantile_algo</span> {
</span></span><span style=display:flex><span>  <span style=color:#e5c07b>void</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e5c07b>int</span> <span style=color:#e06c75>x</span>);
</span></span><span style=display:flex><span>  <span style=color:#e5c07b>int</span> <span style=color:#61afef;font-weight:700>percentile_at</span>(<span style=color:#e5c07b>double</span> <span style=color:#e06c75>percentile</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>add</code>方法将某个数据加入统计，<code>percentile_at</code>方法计算对应的百分位指标。</p><p>本文关注的是如何更快地在线计算延迟。这里的更快，指的是也是更低的延迟，更准确的说是<code>add</code>方法的延迟。一般来说<code>percentile_at</code>方法相对调用频率较少，且不在关键路径上。</p><p>不同Quantile算法的介绍、时间和空间复杂度对比可见<a href=https://caorong.github.io/2020/08/03/quartile-%20algorithm/>这篇文章</a>。这里我们直接说结论，HdrHistogram更符合我们的场景，所以本文着重关注的也是HdrHistogram。</p><h2 id=hdrhistogram>HdrHistogram</h2><p>上面我们提到，HdrHistogram基于静态桶做百分位计算。那么什么叫基于桶的算法呢？考虑到空间开销和时间的开销，我们不能把所有的数据都准确记录下来，那么只能用关键点来sketch多个数据，桶就是sketch数据特征的手段。
举个例子，统计延迟时，如果数据都分布在300ms内，那么可以划分为3个桶:</p><pre tabindex=0><code>Bucket           1                2               3
Range         [0, 100)        [100, 200)      [200, 300)
</code></pre><p>当新遇到一个延迟数据，我们只需要将对应的桶计数+1即可。当有90%的数据都分布在前两个桶中时，我们可以说P90是200ms了。显然这种sketch肯定是有损的，很多情况下不能准确得到Quantile的值，但桶越多，精确度也会越高。</p><p>上面的例子中我们提前知道数据分布范围，但是如果数据的变化较大，不好提前划分桶该怎么办呢？HdrHistogram采用了一种讨巧的方式，结合了指数划分和等间距划分两种分桶方式，将区间内的桶压缩表示出来。取一段代码<a href=https://github.com/HdrHistogram/HdrHistogram_rust/blob/a3818d6ce81556010c7f04f423e1fa28a9ff1b5c/src/lib.rs#L221-L245>注释</a> （修改了typo后）：</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#7f848e>/// `Histogram` is the core data structure in HdrSample. It records values, and performs analytics.
</span></span></span><span style=display:flex><span><span style=color:#7f848e>///
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// At its heart, it keeps the count for recorded samples in &#34;buckets&#34; of values. The resolution
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// and distribution of these buckets is tuned based on the desired highest trackable value, as
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// well as the user-specified number of significant decimal digits to preserve. The values for the
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// buckets are kept in a way that resembles floats and doubles: there is a mantissa and an
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// exponent, and each bucket represents a different exponent. The &#34;sub-buckets&#34; within a bucket
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// represent different values for the mantissa.
</span></span></span><span style=display:flex><span><span style=color:#7f848e>///
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// To a first approximation, the sub-buckets of the first
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// bucket would hold the values `0`, `1`, `2`, `3`, …, the sub-buckets of the second bucket would
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// hold `0`, `2`, `4`, `6`, …, the third would hold `0`, `4`, `8`, and so on. However, the low
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// half of each bucket (except bucket 0) is unnecessary, since those values are already covered by
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// the sub-buckets of all the preceeding buckets. Thus, `Histogram` keeps the top half of every
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// such bucket.
</span></span></span><span style=display:flex><span><span style=color:#7f848e>///
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// For the purposes of explanation, consider a `Histogram` with 2048 sub-buckets for every bucket,
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// and a lowest discernible value of 1:
</span></span></span><span style=display:flex><span><span style=color:#7f848e>///
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// &lt;pre&gt;
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// The 0th bucket covers 0...2047 in multiples of 1, using all 2048 sub-buckets
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// The 1st bucket covers 2048..4095 in multiples of 2, using only the top 1024 sub-buckets
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// The 2nd bucket covers 4096..8191 in multiple of 4, using only the top 1024 sub-buckets
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// ...
</span></span></span><span style=display:flex><span><span style=color:#7f848e>/// &lt;/pre&gt;
</span></span></span></code></pre></div><p>HdrHistogram将桶分成了2层，bucket和sub-bucket，同一bucket内不同sub-bucket等间隔划分，不同bucket指数级别划分。</p><p>注释中的例子，每个bucket中有2048个sub-bucket：</p><ul><li>第0个bucket负责<code>[0, 2048)</code>的数据，每个sub-bucket等间隔<code>1</code>划分，即桶只负责表示<code>(1, 2, 3, ..., 2047)</code></li><li>第1个bucket负责<code>[0, 4096)</code>的数据，每个sub-bucket等间隔<code>2</code>划分。但由于前面的bucket已经cover了前半部分数据，即桶只负责表示<code>(2048, 2050, 2052, ... , 4094)</code></li><li>第2个bucket负责<code>[0, 8192)</code>的数据，每个sub-bucket等间隔<code>4</code>划分。但由于前面的bucket已经cover了前半部分数据，即桶只负责表示<code>(4096, 4100, 4104, ... , 8188)</code></li></ul><p>那么如何将一个数放到对应的bucket中呢？还是以注释中的例子为例。因为<code>2048=2^11</code>，数字二进制中前11位表示sub-bucket index, 剩下的位数表示bucket index。</p><p>举个例子，对于数据<code>4099</code>来说，其二进制表示为<code>0b0001'0000'0000'0011</code>，前半部份<code>0b1'0000'0000'00</code>, 表示sub-bucket为<code>1024</code>（注意除0号bucket外，其余bucket的sub-bucket都只用后半部分），后半部分<code>0b11</code>长度为2，表示bucket-index为<code>2</code>，根据上面的说明，我们会用表示<code>4096</code>的这个桶去存储它。</p><p>HdrHistogram的bucket和sub-bucket数量是如何确定的呢？有三个参数，<code>lowest_discernible_value</code>, <code>highest_trackable_value</code>, <code>significant_figures</code>，分别控制了最小分辨单位、最大统计数据值，精确度大小，进而控制了bucket和sub-bucket的数量。</p><p>如何取Quantile值就相对简单一些了。根据数据总量和每个桶内的数量，从小到大找到百分位的桶和它对应的值即可。</p><h2 id=性能>性能</h2><p>HdrHistogram的add操作没有复杂的计算操作，只是简单通过位运算得到桶下标，并将计数+1，这个过程中只访问内存1次。
理论上来讲，add操作的开销约等于访存开销，根据参数不同，桶的数目不同，访问内存开销也不同，但一般也在ns级别，在各种Quantile算法中是很小的了。（参考<a href=https://www.p99conf.io/session/data-structures-for-high-resolution-real-time-telemetry-at-scale/>这里</a>的benchmark）</p><p>如果想让HdrHistogram更快，可以在编译时就确定参数，那么运行时就可以通过立即数进行计算，减少可能的寄存器读写。这里夹带一些私货，<a href=https://github.com/zingdle/hdrcpp>hdrcpp</a>魔改了HdrHistogram_c的实现，在我的机器上可以将单次add操作从~4ns降低到~2.5ns。</p></div></article></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://github.com/zingdle target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></div><small class=footer_copyright>© 2025 .
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel=noopener>Hugo blog awesome</a>.</small></footer><a href=# title="Go to top" id=totop><svg width="48" height="48" fill="currentcolor" stroke="currentcolor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"/></svg>
</a><script src=https://zingdle.github.io/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30+lSNuSkl4QXuNyy8="></script></body></html>